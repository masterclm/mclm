% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/freqlist.R
\name{subset_freqlist}
\alias{subset_freqlist}
\alias{drop_types.freqlist}
\alias{keep_types.freqlist}
\alias{drop_re.freqlist}
\alias{keep_re.freqlist}
\alias{drop_bool.freqlist}
\alias{keep_bool.freqlist}
\alias{drop_pos.freqlist}
\alias{keep_pos.freqlist}
\alias{[.freqlist}
\title{Subset a 'freqlist' object}
\usage{
\method{drop_types}{freqlist}(x, types, ...)

\method{keep_types}{freqlist}(x, types, invert = FALSE, ...)

\method{drop_re}{freqlist}(x, pattern, perl = TRUE, ...)

\method{keep_re}{freqlist}(x, pattern, perl = TRUE, invert = FALSE, ...)

\method{drop_bool}{freqlist}(x, bool, ...)

\method{keep_bool}{freqlist}(x, bool, invert = FALSE, ...)

\method{drop_pos}{freqlist}(x, pos, ...)

\method{keep_pos}{freqlist}(x, pos, invert = FALSE, ...)

\method{[}{freqlist}(x, i, invert = FALSE, ...)
}
\arguments{
\item{x}{Object of class \code{freqlist}.}

\item{types}{Either an object of the class \code{'types'}
(see \code{\link{types}} and \code{\link{as_types}}) or a character vector.
Assuming \code{invert} is \code{FALSE}, the items whose names are included
in these argument are selected.}

\item{...}{Additional arguments.}

\item{invert}{Boolean vector of length one, which indicates whether the matches
or the non-matches should be selected.}

\item{pattern}{Either an object of the class \code{'re'} (see \code{\link{re}})
or a character vector of length one, which contains a regular expression.}

\item{perl}{Boolean vector of length one, which indicates whether or not
\code{pattern} is treated as a PCRE flavor regular expression.
The \code{perl} argument is only used if \code{pattern} is a regular character vector.
If \code{pattern} is an object of the class \code{'re'}, then the
\code{perl} argument is ignored, and the relevant information in the
\code{'re'} object \code{pattern}, viz. the value of \code{pattern$perl}, is
used instead.}

\item{bool}{A logical vector of the same length as \code{x}. If \code{bool} is not
of the correct length, it is \emph{recycled}. Assuming \code{invert} is
\code{FALSE}, those items are selected for which \code{bool} is \code{TRUE}.}

\item{pos}{A numeric vector, the numbers in which identify positions (= indices)
of items in \code{x}.

If the numbers are positive, then their values point
to the items that are to be selected.

If the numbers are negative,
then their absolute values point to the items that are not to be selected.
Positive and negative numbers must not be mixed.}

\item{i}{Selection criterion when subsetting with \code{[]}; depending on its
class, it behaves differently:
 \describe{
   \item{\code{re}}{It works like \code{keep_re}.}
   \item{numeric}{It works like \code{keep_pos}.}
   \item{logical}{It works like \code{keep_bool}.}
   \item{\code{types} or character}{It works like \code{keep_types}.}
 }}
}
\value{
Object of class \code{freqlist} with the selected elements only.
}
\description{
These methods can be used to subset objects of class \code{freqlist} by position, list of types,
regular expression match or via boolean statements.
}
\section{Methods (by generic)}{
\itemize{
\item \code{drop_types}: Drop items by names of types

\item \code{keep_types}: Keep items by names of types

\item \code{drop_re}: Drop items by regular expression

\item \code{keep_re}: Keep items by regular expression

\item \code{drop_bool}: Keep items based on boolean expression

\item \code{keep_bool}: Keep items based on boolean expression

\item \code{drop_pos}: Keep items by position

\item \code{keep_pos}: Keep items by position

\item \code{[}: Keep items based on different criteria
}}

\examples{

(flist <- freqlist("The man and the mouse.", as_text = TRUE))

keep_re(flist, "[ao]")
drop_re(flist, "[ao]")
keep_re(flist, "[ao]", invert = TRUE) # same as drop_re()

flist[re("[ao]")]
flist[re("[ao]"), invert = TRUE]

keep_bool(flist, type_freqs(flist) < 2)
drop_bool(flist, type_freqs(flist) >= 2)
keep_bool(flist, ranks(flist) <= 3)

flist[type_freqs(flist) < 2]
flist[ranks(flist) <= 3]
flist[ranks(flist) <= 3, invert = TRUE]

keep_bool(flist, c(FALSE, TRUE, TRUE, FALSE)) 

(flist2 <- keep_bool(flist, type_freqs(flist) < 2))
keep_bool(flist2, orig_ranks(flist2) > 2)
flist2[orig_ranks(flist2) > 2]

keep_pos(flist, c(2, 3))
flist[2:3]

keep_types(flist, c("man", "and"))
drop_types(flist, c("man", "and"))
keep_types(flist, c("man", "and"), invert = TRUE) # same as drop_types()
flist[c("man", "and")]
flist[as_types(c("man", "and"))]
}
