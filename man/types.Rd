% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/types.R
\name{types}
\alias{types}
\title{Build a 'types' object}
\usage{
types(
  x,
  re_drop_line = NULL,
  line_glue = NULL,
  re_cut_area = NULL,
  re_token_splitter = re("[^_\\\\p{L}\\\\p{N}\\\\p{M}'-]+"),
  re_token_extractor = re("[_\\\\p{L}\\\\p{N}\\\\p{M}'-]+"),
  re_drop_token = NULL,
  re_token_transf_in = NULL,
  token_transf_out = NULL,
  token_to_lower = TRUE,
  perl = TRUE,
  blocksize = 300,
  verbose = FALSE,
  show_dots = FALSE,
  dot_blocksize = 10,
  file_encoding = "UTF-8",
  ngram_size = NULL,
  ngram_sep = "_",
  ngram_n_open = 0,
  ngram_open = "[]",
  as_text = FALSE
)
}
\arguments{
\item{x}{Either a list of filenames of the corpus files
(if \code{as_text} is \code{TRUE}) or the actual text of the corpus
(if \code{as_text} is \code{FALSE}).

If \code{as_text} is \code{TRUE} and the length of the vector \code{x}
is higher than one, then each item in \code{x} is treated as a separate
line (or a separate series of lines) in the corpus text. Within each
item of \code{x}, the character \code{"\\\\n"} is also treated as
a line separator.}

\item{re_drop_line}{\code{NULL} or character vector. If \code{NULL}, it is ignored.
Otherwise, a character vector (assumed to be of length 1)
containing a regular expression. Lines in \code{x}
that contain a match for \code{re_drop_line} are
treated as not belonging to the corpus and are excluded from the results.}

\item{line_glue}{\code{NULL} or character vector. If \code{NULL}, it is ignored.
Otherwise, all lines in a corpus file (or in \code{x}, if
\code{as_text} is \code{TRUE}), are glued together in one
character vector of length 1, with the string \code{line_glue}
pasted in between consecutive lines.
The value of \code{line_glue} can also be equal to the empty string \code{""}.
The 'line glue' operation is conducted immediately after the 'drop line' operation.}

\item{re_cut_area}{\code{NULL} or character vector. If \code{NULL}, it is ignored.
Otherwise, all matches in a corpus file (or in \code{x},
if \code{as_text} is \code{TRUE}), are 'cut out' of the text prior
to the identification of the tokens in the text (and are therefore
not taken into account when identifying the tokens).
The 'cut area' operation is conducted immediately after the 'line glue' operation.}

\item{re_token_splitter}{Regular expression or \code{NULL}.
Regular expression that identifies the locations where lines in the corpus
files are split into tokens. (See Details.)

The 'token identification' operation is conducted immediately after the
'cut area' operation.}

\item{re_token_extractor}{Regular expression that identifies the locations of the
actual tokens. This argument is only used if \code{re_token_splitter} is \code{NULL}.
(See Details.)

The 'token identification' operation is conducted immediately after the
'cut area' operation.}

\item{re_drop_token}{Regular expression or \code{NULL}. If \code{NULL}, it is ignored.
Otherwise, it identifies tokens that are to
be excluded from the results. Any token that contains a match for
\code{re_drop_token} is removed from the results.
The 'drop token' operation is conducted immediately after the 'token identification' operation.}

\item{re_token_transf_in}{Regular expression that identifies areas in the
tokens that are to be transformed. This argument works together with the argument
\code{token_transf_out}.

If both \code{re_token_transf_in} and \code{token_transf_out} differ
from \code{NA}, then all matches, in the tokens, for the
regular expression  \code{re_token_transf_in} are replaced with
the replacement string \code{token_transf_out}.

The 'token transformation' operation is conducted immediately after the
'drop token' operation.}

\item{token_transf_out}{Replacement string. This argument works together with
\code{re_token_transf_in} and is ignored if \code{re_token_transf_in}
is \code{NULL} or \code{NA}.}

\item{token_to_lower}{Boolean value. Whether tokens must be converted
to lowercase before returning the result.
The 'token to lower' operation is conducted immediately after the
'token transformation' operation.}

\item{perl}{Boolean value. Whether the PCRE regular expression
flavor is being used in the arguments that contain regular expressions.}

\item{blocksize}{Number that indicates how many corpus files are read to memory
\verb{at each individual step' during the steps in the procedure; normally the default value of }300` should not
be changed, but when one works with exceptionally small corpus files,
it may be worthwhile to use a higher number, and when one works with
exceptionally large corpus files, it may be worthwhile to use a lower number.}

\item{verbose}{If\code{TRUE}, messages are printed to the console to
indicate progress.}

\item{show_dots, dot_blocksize}{If \code{TRUE}, dots are printed to the console to
indicate progress.}

\item{file_encoding}{File encoding that is assumed in the corpus files.}

\item{ngram_size}{Argument in support of ngrams/skipgrams (see also \code{max_skip}).

If one wants to identify individual tokens, the value of \code{ngram_size}
should be \code{NULL} or \code{1}. If one wants to retrieve
token ngrams/skipgrams, \code{ngram_size} should be an integer indicating
the size of the ngrams/skipgrams. E.g. \code{2} for bigrams, or \code{3} for
trigrams, etc.}

\item{ngram_sep}{Character vector of length 1 containing the string that is used to
separate/link tokens in the representation of ngrams/skipgrams
in the output of this function.}

\item{ngram_n_open}{If \code{ngram_size} is \code{2} or higher, and moreover
\code{ngram_n_open} is a number higher than \code{0}, then
ngrams with 'open slots' in them are retrieved. These
ngrams with 'open slots' are generalisations of fully lexically specific
ngrams (with the generalisation being that one or more of the items
in the ngram are replaced by a notation that stands for 'any arbitrary token').

For instance, if \code{ngram_size} is \code{4} and \code{ngram_n_open} is
\code{1}, and if moreover the input contains a
4-gram \code{"it_is_widely_accepted"}, then the output will contain
all modifications of \code{"it_is_widely_accepted"} in which one (since
\code{ngram_n_open} is \code{1}) of the items in this n-gram is
replaced by an open slot. The first and the last item inside
an ngram are never turned into an open slot; only the items in between
are candidates for being turned into open slots. Therefore, in the
example, the output will contain \code{"it_[]_widely_accepted"} and
\code{"it_is_[]_accepted"}.

As a second example, if \code{ngram_size} is \code{5} and
\code{ngram_n_open} is \code{2}, and if moreover the input contains a
5-gram \code{"it_is_widely_accepted_that"}, then the output will contain
\code{"it_[]_[]_accepted_that"}, \code{"it_[]_widely_[]_that"}, and
\code{"it_is_[]_[]_that"}.}

\item{ngram_open}{Character string used to represent open slots in ngrams in the
output of this function.}

\item{as_text}{Boolean vector, assumed to be of length 1. Whether
\code{x} is to be interpreted as a character vector containing the
actual contents of the corpus (if \code{as_text} is \code{TRUE})
or as a character vector containing the names of the corpus files
(if \code{as_text} is \code{FALSE}).
If if \code{as_text} is \code{TRUE}, then the arguments
\code{blocksize}, \code{verbose}, \code{show_dots}, \code{dot_blocksize},
and \code{file_encoding} are ignored.}
}
\value{
An object of the class \code{types}, which is based on a character vector.
It has additional attributes and methods such as:
\itemize{
\item base \code{\link[=print.types]{print()}}, \code{\link[=as.data.frame]{as.data.frame()}}, \code{\link[=sort]{sort()}} and
\code{\link[base:summary]{base::summary()}} (which returns the number of items and of unique items),
\item \code{\link[tibble:as_tibble]{tibble::as_tibble()}},
\item the \code{\link[=n_types]{n_types()}} getter and the \code{\link[=explore]{explore()}} method,
\item subsetting methods such as \code{\link[=keep_types]{keep_types()}}, \code{\link[=keep_pos]{keep_pos()}}, etc. including \verb{[]}
subsetting (see \link{brackets}).
}

An object of class \code{types} can be merged with another by means of \code{\link[=types_merge]{types_merge()}},
written to file with \code{\link[=write_types]{write_types()}} and read from file with \code{\link[=write_types]{write_types()}}.
}
\description{
This function builds an object of the class \code{\link[=types]{types()}}.
}
\details{
The actual token identification is either based on the \code{re_token_splitter}
argument, a regular expression that identifies the areas between the tokens,
or on \code{re_token_extractor}, a regular expression that identifies the area
that are the tokens.
The first mechanism is the default mechanism: the argument \code{re_token_extractor}
is only used if \code{re_token_splitter} is \code{NULL}.
Currently the implementation of
\code{re_token_extractor} is a lot less time-efficient than that of \code{re_token_splitter}.
}
\examples{
toy_corpus <- "Once upon a time there was a tiny toy corpus.
It consisted of three sentences. And it lived happily ever after."
(tps <- types(toy_corpus, as_text = TRUE))
print(tps)

as.data.frame(tps)
as_tibble(tps)

sort(tps)
sort(tps, decreasing = TRUE)
}
\seealso{
\code{\link[=as_types]{as_types()}}
}
